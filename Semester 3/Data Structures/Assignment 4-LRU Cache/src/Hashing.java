//------Class : public class Hashing<K, V> ----------
/*This  Class implements the hashing method and its required procedures as given below:  */
public class Hashing<K, V> {
    private Node<K, V>[] HashTable;                                 // creation of our hashing table                             
    private static final int DEFAULT_CAPACITY = 5;                  // initialize  the  capacity of the table

    public Hashing() {
        HashTable = new Node[DEFAULT_CAPACITY];
    }
//------Method : private int hash(K key);-------
/*This method is the hashing tool of our programm ,it returns an integer pointer generated in combination of a key and DEFAULT_CAPACITY (hash table size)  */
    private int hash(K key) {
        return Math.abs(key.hashCode() % DEFAULT_CAPACITY);
    }

//------Method : public void insert(K key, V value);-------
/*This void method inserts a node in the hashing table, the position is determined by the hash function */
    public void insert(K key, V value) {
        if (key == null)                                            // null keys are not allowed
            return;
        Node<K, V> node = new Node<K, V>(null, null, key, value);   // new node to store the value and the key at once
        int x = hash(key);                                          // integer x : the pointer generated by the hash method
        if (HashTable[x] == null)                                   // empty position ? 
            HashTable[x] = node;                                    // we isert the node
        else {                                                      // if the position is not empty we have to find the edge of the linked list tha was created due to collisions
            Node<K, V> firstnode = HashTable[x];                    // temporal node to store the existing item in the hash table
            while (firstnode.getNext() != null) {                   // begin searching....
                firstnode = firstnode.getNext();                    // continue through the list
            }
            firstnode.setNext(node);                                // link the node at the edge with the new node
        }
    }

//------Method : public V get(K key);-------
/*This method returnes a Value (V) that coresponds to the given key*/
    public V get(K key) {
        int x = hash(key);                                          // integer x : the pointer generated by the hash method
        if (HashTable[x] == null)                                   // determine if the item in given position is null(empty position)
            return null;
        Node<K, V> firstnode = HashTable[x];                        // new node to store temporary the existing item in position
        while (firstnode != null) {                                 // while statement helps finding the requested value
            if (firstnode.getKey().equals(key))
                return firstnode.getValue();                        // return the requested valuue
            firstnode = firstnode.getNext();                        // change node value to next node
        }
        return null;
    }

//------Method : public boolean remove(K key);-------
/*This method remmoves a requested item that coresponds to the given key 
If the removal was successful returns True else False  */
    public boolean remove(K key) {
        int x = hash(key);                                          // integer x : the pointer generated by the hash method
        if (HashTable[x] != null) {                                 // cant remove a null item so the content must be checked
            Node<K, V> firstnode = HashTable[x];                    // new node to store temporary the existing item in position
            Node<K, V> prev = null;                                 // node to store the previous node inside the while statement
            while (firstnode != null) {
                if (firstnode.getKey().equals(key)) {               // if the requested key found the the method removes the item and returns True
                    if (prev == null)                               // if we enter the loop for the first time we change the node iside the table,
                        HashTable[x] = HashTable[x].getNext();      // with its next node
                    else
                        prev.setNext(firstnode.getNext());          // otherwise we link the previous node  with the first's node's following node
                    return true;
                }
                prev = firstnode;
                firstnode = firstnode.getNext();                    // continue searching...
            }
        }
        return false;                                               // unsuccessful removal
    }
}

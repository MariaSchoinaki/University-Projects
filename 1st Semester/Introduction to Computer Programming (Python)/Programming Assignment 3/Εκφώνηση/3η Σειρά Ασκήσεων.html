<!DOCTYPE html>
<head>
  <meta charset='utf-8'>
  <title>Σειρά Ασκήσεων 3</title>
<link rel='stylesheet' href='https://eclass.aueb.gr/template/default/CSS/bootstrap-custom.css'><link rel='stylesheet' href='https://eclass.aueb.gr/template/default/CSS/font-awesome-4.7.0/css/font-awesome.css'><style>body { margin: 8px; background: none !important; }</style></head>
<body>
<p>Στην άσκηση αυτή θα συμπληρώσετε τον κώδικα Python που βρίσκεται στο αρχείo <a href="/modules/document/file.php/INF259/hw3.py">hw3.py</a> ακολουθώντας τις ίδιες <a href="/modules/document/file.php/INF259/page_1.html">οδηγίες</a> (δείτε και <a href="/modules/announcements/index.php?course=INF259&amp;an_id=56969">εδώ</a>) με αυτές που δόθηκαν στη Σειρά Ασκήσεων 1.</p>
<h3>Τρόπος παράδοσης:</h3>
<p>Θα παραδώσετε το αρχείο hw3.py (σημ.: δεν χρειάζεται να το συμπιέσετε).</p>
<ol><li>Οι φοιτητές που έχουν εγγραφεί στο eclass θα παραδόσουν την εργασία μέσα από εκεί.</li>
<li>Οι φοιτητές που δεν έχουν εγγραφεί στο eclass θα την παραδώσουν με email στο dimakis@aueb.gr με θέμα (subject): [2021 - ΑΣΚΗΣΗ 3] (με τις αγκύλες) που επίσης περιέχει το ονοματεπώνυμο τους στο σώμα του μηνύματος <em>και</em> σε σχόλιο μέσα στο hw3.py.</li>
</ol><h3>Άσκηση 1</h3>
<p>Θα πρέπει να υλοποιήσετε ένα αφηρημένο τύπο δεδομένου (όπως ο rational στη <a href="/modules/document/file.php/INF259/%CE%94%CE%B9%CE%B1%CE%BB%CE%AD%CE%BE%CE%B5%CE%B9%CF%82/6_Data_abstractions.pdf">Διάλεξη 11</a>) που αναπαριστά μια "γεωγραφική τοποθεσία", συμπληρώνοντας τον κώδικα στα κενά _________ του <em>κατασκευαστή</em> (<em>constructor</em>) location και των <em>συναρτήσεων επιλογής</em> (<em>selectors</em>) name, longitude, lattitude, type.</p>
<p>Η κλήση location(name, lat, lon, type) πρέπει να κατασκευάζει (επιστρέφει) το αφηρημένο δεδομένο τοποθεσίας με τοπωνύμιο name, το οποίο βρίσκεται στο γεωγραφικό πλάτος και μήκος lat και lon αντίστοιχα, και το είδος της τοποθεσίας δίνεται στη συμβολοσειρά (str) type, πχ., 'monument', 'park'.</p>
<p>Συμπληρώστε τα κενά των <em>συναρτήσεων επιλογής</em> του δεδομένου location, δηλαδή στις συναρτήσεις name, longitude, latitude και type, έτσι ώστε για μια τοποθεσία loc (δηλ., δεδομένο location):</p>
<ul><li>H κλήση name(loc) να επιστρέφει το όνομα της τοποθεσίας loc.</li>
<li>Η longitude(loc) να επιστρέφει το γεωγραφικό μήκος που βρίσκεται η loc.</li>
<li>Η lattitude(loc) να επιστρέφει το γεωγραφικό πλάτος που βρίσκεται η loc.</li>
<li>Η type(loc) να επιστρέφει το είδος της τοποθεσίας, δηλ. την τιμή του ορίσματος type της συνάρτησης location που χρησιμοποιήθηκε κατά την κατασκευή του loc.</li>
</ul><table style="height:22px;" width="589"><tbody><tr><td style="width:579px;">
<pre>def location(name, lat, lon, type):<br />    """Kataskeuazei syn8eto dedomeno topo8esias (location).<br /><br />    name -- onoma (str)<br />    lat -- gewfrafiko platos (se moires)<br />    lon -- gewgrafiko mikos (se moires)<br />    type -- eidos topo8esias (str)<br /><br />    Epistrefei dedomeno pou anaparista tin topo8esia me onoma name h opoia<br />    brisketai sto gewgrafiko platos kai mikos lat kai lon antistoixa. To type<br />    einai string pou perigrafei to eidos tis topo8esias, p.x., 'monument',<br />    'bus station'.<br />    """<br />    return ______________________________<br /><br /><br />def name(loc):<br />    """Epistrefei to onoma mias topo8esias.<br /><br />    loc -- topo8esia (typou location)<br /><br />    Epistrefei to onoma (str) tis topo8esias loc.<br /><br />    &gt;&gt;&gt; monast = location('Monastiraki', 37.976362, 23.725947, 'square')<br />    &gt;&gt;&gt; name(monast)<br />    'Monastiraki'<br />    """<br />    return _________________<br /><br /><br />def longitude(loc):<br />    """Gewgrafiko mikos.<br /><br />    loc -- dedomeno location<br /><br />    Epistrefei gewgrafiko mikos tis topo8esias loc<br /><br />    &gt;&gt;&gt; monast = location('Monastiraki', 37.976362, 23.725947, 'square')<br />    &gt;&gt;&gt; longitude(monast)<br />    23.725947<br />    """<br />    return _________________<br /><br /><br />def lattitude(loc):<br />    """Gewgrafiko platos.<br /><br />    loc -- dedomeno location<br /><br />    Epistrefei gewgrafiko mikos tis topo8esias loc<br /><br />    &gt;&gt;&gt; monast = location('Monastiraki', 37.976362, 23.725947, 'square')<br />    &gt;&gt;&gt; lattitude(monast)<br />    37.976362<br />    """<br />    return _________________<br /><br /><br />def type(loc):<br />    """Eidos topo8esias.<br /><br />    loc -- dedomeno location<br /><br />    Epistrefei string pou perigrafei to eidos tis topo8esias loc, p.x.,<br />    'monument', 'bus station'.<br /><br />    &gt;&gt;&gt; monast = location('Monastiraki', 37.976362, 23.725947, 'square')<br />    &gt;&gt;&gt; type(monast)<br />    'square'<br />    """<br />    return _________________</pre>
</td>
</tr></tbody></table><h3>Άσκηση 2</h3>
<p>Συμπληρώστε τον κώδικα ή τα κενά _________ στις συναρτήσεις distance, print_location και nearest_location, έτσι ώστε να δίνουν τα επιθυμητά αποτελέσματα, χ<em>ωρίς όμως να κάνετε χρήση της αναπαράστασης των δεδομένων location που βρίσκεται εσωτερικά στον κώδικα κατασκευαστή και συναρτήσεων επιλογής στην Άσκηση 1</em>. <em><span style="text-decoration:underline;">Ο κώδικας των συναρτήσεων θα πρέπει να χρησιμοποιεί τα αφηρημένα δεδομένα location μόνο μέσω κλήσεων στον κατασκευαστή και στις συναρτήσεις επιλογής της Άσκησης 1</span> . (Σημειώστε ότι οι συναρτήσεις αυτές θα πρέπει να εξακολουθούν να λειτουργούν σωστά -και χωρίς να χρειαστεί να αλλάξουν- ακόμη και αν οι συναρτήσεις location, name, longitude, lattitude στην Άσκηση 1 είχαν υλοποιηθεί με διαφορετικό τρόπο.)</em></p>
<p>Η κλήση distance(a, b) επιστρέφει την απόσταση (σε χιλιόμετρα) μεταξύ των τοποθεσιών που αναπαριστάνουν τα δεδομένα a, b τύπου location. Η print_location(loc) εμφανίζει στοιχεία για την τοποθεσία loc. Η nearest_location(loc, loc_list, loc_type) επιστρέφει το δεδομένο location που βρίσκεται στη λίστα με τοποθεσίες loc_list το οποίο απέχει τη μικρότερη απόσταση από την τοποθεσία loc και είναι τύπου loc_type. Εάν το είδος της τοποθεσίας παραληφθεί, π.χ., καλώντας nearest_location(loc, loc_list), τότε επιστρέφεται η κοντυνότερη τοποθεσία ανάμεσα σε αυτές στη loc_list ανεξάρτητα από το είδος της.</p>
<table style="height:28px;" width="588"><tbody><tr><td style="width:578px;">
<pre>def distance(a, b):<br />    """Apostasi meta3y topo88esiwn.<br /><br />    a -- topo8esia A (afirimeno dedomeno typou location)<br />    b -- topo8esia B (afirimeno dedomeno typou location)<br /><br />    Epistrefei tin apostasi<br />    meta3y ths topo8esias A kai B se xiliometra.<br /><br />    &gt;&gt;&gt; aueb = location('AUEB', 37.994097, 23.732253, 'university campus')<br />    &gt;&gt;&gt; monast = location('Monastiraki', 37.976362, 23.725947, 'square')<br />    &gt;&gt;&gt; distance(aueb, monast)<br />    2.5224714882938657<br />    &gt;&gt;&gt; distance(aueb, aueb)<br />    0.0<br />    """<br />    a_lat = _____________________ # gewgrafiko platos (lattitude) a<br />    a_lon = _____________________ # gewgrafiko mikos (longitude) a<br />    b_lat = _____________________ # gewgrafiko platos (lattitude) b<br />    b_lon = _____________________ # gewgrafiko mikos (longitude) b<br /><br />    from math import pi, cos<br />    phi_m = pi/180 * (a_lat + b_lat) / 2<br />    k1 = 111.13209 - 0.56605 * cos(2*phi_m) + 0.00120 * cos(4*phi_m)<br />    k2 = 111.41513 * cos(phi_m) - 0.0945 * cos(3*phi_m) + 0.00012*cos(5*phi_m)<br />    lat_dist = (a_lat - b_lat) * k1<br />    lon_dist = (a_lon - b_lon) * k2<br />    return abs(lon_dist) + abs(lat_dist)<br /><br /><br />def print_location(loc):<br />    """Emfanizei stoixeia topo8esias.<br /><br />    loc -- dedomeno location<br /><br />    Emfanizei stoixeia gia tin topo8esia loc opws sta paradeigmata:<br /><br />    &gt;&gt;&gt; monast = location('Monastiraki', 37.976362, 23.725947, 'square')<br />    &gt;&gt;&gt; print_location(monast)<br />    Monastiraki (square) at coordinates 37.976362, 23.725947<br />    &gt;&gt;&gt; print_location(location('North Pole', 90.0, 135.0, 'pole'))<br />    North Pole (pole) at coordinates 90.0, 135.0<br />    """<br />    """GRAPSTE TON KWDIKA SAS APO KATW."""<br /><br /><br />def nearest_location(loc, loc_list, loc_type=None):<br />    """Epistrefei plisiesteri topo8esia.<br /><br />    loc -- topo8esia (dedomeno typoy location)<br />    loc_list -- lista pou periexei topo8esies (dedomena location)<br />    loc_type -- eidos topo8esias (str)<br /><br />    Epistrefei tin plisiesteri topo8esia stin loc apo autes pou briskonai sti<br />    lista loc_list tou eidous loc_type.<br /><br />    Paradeigmata:<br />    &gt;&gt;&gt; llist = [location('AUEB', 37.994097, 23.732253, 'university campus'),\<br />                  location('Acropolis', 37.971584, 23.725912, 'monument'), \<br />                  location('Syntagma', 37.975560, 23.734691, 'square'), \<br />                  location('National Garden', 37.973116, 23.736483, 'park'), \<br />                  location('Monastiraki', 37.976362, 23.725947, 'square')]<br />    &gt;&gt;&gt; name(nearest_location(llist[2], llist, 'monument'))<br />    'Acropolis'<br />    &gt;&gt;&gt; name(nearest_location(llist[1], llist, 'square'))<br />    'Monastiraki'<br />    &gt;&gt;&gt; name(nearest_location(llist[2], llist))<br />    'National Garden'<br />    &gt;&gt;&gt; name(nearest_location(llist[2], llist, 'square'))<br />    'Monastiraki'<br />    """<br />    """GRAPSTE TON KWDIKA SAS APO KATW."""</pre>
</td>
</tr></tbody></table><h3>Άσκηση 3</h3>
<p>Συμπληρώστε τα κενά _________ ώστε η κλήση pick_cherries_only() να έχει το αποτέλεσμα που περιγράφεται στα σχόλια.</p>
<table style="height:26px;" width="423"><tbody><tr><td style="width:413px;">
<pre>def pick_cherries_only():<br />    """Emfanizei string pou briskontai se fwliasmenes listes.<br /><br />    Prepei na exei to akolou8o apotelesma:<br /><br />    &gt;&gt;&gt; pick_cherries_only()<br />    cherry1<br />    cherry2<br />    cherry3<br />    cherry4<br />    Yay!!!<br />    """<br />    """ SYMPLHRWSTE TA KENA APO KATW."""<br />    fruits = ['cherry1', 'orange', \<br />              ['grape', 'cherry2', ['cherry3'], 'banana'], \<br />              None, 'cherry4', [[['Yay!!!']]]]<br /><br />    print(fruits[0])<br />    print(fruits__________________)<br />    print(fruits__________________)<br />    print(fruits__________________)<br />    print(fruits__________________)</pre>
</td>
</tr></tbody></table><h3>Άσκηση 4</h3>
<p>Συμπληρώστε τα κενά ώστε η κλήση pick_cherries_onebyone() να έχει το αποτέλεσμα που περιγράφεται στα σχόλια, <em>χωρίς να χρησιμοποιήσετε πρωταρχικές εκφράσεις όπως</em> 'cherry2', 'cherry3', κτλ.  </p>
<table style="height:26px;" width="423"><tbody><tr><td style="width:413px;">
<pre>def pick_cherries_onebyone():<br />    """Emfanizei string pou briskontai se fwliasmenes listes.<br /><br />    Prepei na exei to akolou8o apotelesma:<br /><br />    &gt;&gt;&gt; pick_cherries_onebyone()<br />    cherry1<br />    cherry2<br />    cherry3<br />    cherry4<br />    last cherry<br />    """<br />    """ SYMPLHRWSTE TA KENA APO KATW."""<br />    cherry_field = ['cherry1', ['cherry2', ['cherry3', ['cherry4', ['last cherry', None]]]]]<br /><br />    print(cherry_field[0])<br />    ______________________________<br />    print(cherry_field[0])<br />    ______________________________<br />    print(cherry_field[0])<br />    ______________________________<br />    print(cherry_field[0])<br />    ______________________________<br />    print(cherry_field[0])</pre>
</td>
</tr></tbody></table><h3>Άσκηση 5</h3>
<p>Συμπληρώστε τα κενά ώστε η κλήση pick_cherries(field) να εμφανίζει τις συμβολοσειρές (str) οι οποίες βρίσκονται στην πρώτη θέση των φωλιασμένων λιστών που δίνονται στο όρισμα field, όπως στα παραδείγματα των σχολίων.</p>
<p>Θεωρήστε ότι το όρισμα field είναι μια φωλιασμένη λίστα της ίδιας μορφής με την cherry_field της Άσκησης 4, με οσεσδήποτε πολλές φωλιασμένες λίστες όμως όπου πάντα το πρώτο τους στοιχείο είναι συμβολοσειρά (str). Το δεύτερο στοιχείο της τελευταίας λίστας (δηλ., αυτής που περιέχεται σε όλες τις άλλες) έχει τιμή None.</p>
<p><em>Η υλοποίησή σας πρέπει να χρησιμοποιεί την εντολή while στο σώμα της pick_cherries. (Σημειώστε ότι το πλήθος των γραμμών με κενά είναι ενδεικτικό μόνο: μπορείτε να χρησιμοποιήσετε περισσότερες ή λιγότερες τέτοιες γραμμές.)</em></p>
<table style="height:5px;" width="583"><tbody><tr><td style="width:573px;">
<pre>def pick_cherries(field):<br />    """Emfanizei string pou briskontai se fwliasmenes listes.<br /><br />    field -- lista me fwliasmena string. Ka8e lista exei dyo stoixeia: <br />    to prwto einai string kai to deutero einai eite lista ths idias <br />    morfhs 'h None. (Opws kai h cherry_field sto swma ths synarthshs <br />    pick_cherries_onebyone()).<br /><br />    Leitoyrgei opws i pick_cherries_onebyone, omws gia au8aireta polles<br />    fwliasmenes listes stin field.<br /><br />    Paradeigmata:<br /><br />    &gt;&gt;&gt; cherry_field = ['cherry1', ['cherry2', ['cherry3', ['cherry4', ['last cherry', None]]]]]<br />    &gt;&gt;&gt; pick_cherries(cherry_field)<br />    cherry1<br />    cherry2<br />    cherry3<br />    cherry4<br />    last cherry<br />    &gt;&gt;&gt; pick_cherries(['Hello', ['world', None]])<br />    Hello<br />    world<br />    """<br />    """ SYMPLHRWSTE TA KENA APO KATW."""<br />    ________________<br />    ________________<br />    while ______________:<br />        ____________________<br />        print(______________)<br />        ____________________</pre>
</td>
</tr></tbody></table><h3> Άσκηση 6</h3>
<p>Συμπληρώστε τον κώδικα στη συνάρτηση all_iter έτσι ώστε η κλήση all_iter(func, ls) να επιστρέφει True εάν και μόνο εάν η κλήση func(x) έχει τιμή True <em>για όλα</em> τα στοιχεία x της λίστας ls. </p>
<p><em>Η υλοποίησή σας θα πρέπει να χρησιμοποιεί <strong>επαναληπτικό υπολογισμό, δηλ., την εντολή while ή for,</strong><span style="text-decoration:underline;"> χωρίς comprehensions ή αναδρομικό υπολογισμό</span>. (Στις ασκήσεις 7 εως 9 θα υλοποιήσετε την ίδια συνάρτηση με τους άλλους τρόπους.)</em></p>
<pre>def all_iter(func, ls):<br />    """True mono ean i klisi func(x) epistrefei True <br />    gia ola ta stoixeia x tis ls.<br /><br />    func -- synartisi enos orismatos<br />    ls -- lista<br /><br />    Paradeigmata:<br />    &gt;&gt;&gt; all_iter(lambda x: x &gt;= 0, [1, 2, 3, 0, 4])<br />    True<br />    &gt;&gt;&gt; all_iter(lambda x: x &gt;= 0, [1, 2, -3, 0, 4])<br />    False<br />    &gt;&gt;&gt; all_iter(lambda x: x % 2 == 0, [100, 10, 2022, 12])<br />    True<br />    """<br />    """XRHSIMOPOIHSTE EPANALHPTIKO YPOLOGISMO (for 'h while).<br />    MHN XRHSIMOPOIHSETE LIST COMPREHENSIONS 'h ANADROMI."""<br />    """GRAPSTE TON KWDIKA SAS APO KATW."""</pre>
<h3>Άσκηση 7</h3>
<p>Συμπληρώστε τον κώδικα στη συνάρτηση all_rec έτσι ώστε η κλήση all_rec(func, ls) να επιστρέφει True εάν και μόνο εάν η κλήση func(x) έχει τιμή True <em>για</em> <em>όλα</em> τα στοιχεία x της λίστας ls. </p>
<p><em>Η υλοποίησή σας θα πρέπει να χρησιμοποιεί <strong>αναδρομικό υπολογισμό</strong><span style="text-decoration:underline;">, χωρίς </span><span style="text-decoration:underline;">επαναληπτικό υπολογισμό, (δηλ., την εντολή while ή fo)r ή comprehensions </span>. (Στις ασκήσεις 6 εως 9 θα υλοποιήσετε την ίδια συνάρτηση με τους άλλους τρόπους.)</em></p>
<pre>def all_rec(func, ls):<br />    """True mono ean i klisi func(x) epistrefei True <br />    gia ola ta stoixeia x tis ls.<br /><br />    func -- synartisi enos orismatos<br />    ls -- lista<br /><br />    Paradeigmata:<br />    &gt;&gt;&gt; all_rec(lambda x: x &gt;= 0, [1, 2, 3, 0, 4])<br />    True<br />    &gt;&gt;&gt; all_rec(lambda x: x &gt;= 0, [1, 2, -3, 0, 4])<br />    False<br />    &gt;&gt;&gt; all_rec(lambda x: x % 2 == 0, [100, 10, 2022, 12])<br />    True<br />    """<br />    """XRHSIMOPOIHSTE ANADROMH.<br />    MHN XRHSIMOPOIHSETE LIST COMPREHENSIONS 'h EPANALHPTIKO YPOLOGISMO <br />    (for 'h while)."""<br />    """GRAPSTE TON KWDIKA SAS APO KATW."""</pre>
<h3> Άσκηση 8</h3>
<p>Συμπληρώστε τον κώδικα στη συνάρτηση all_lc έτσι ώστε η κλήση all_lc(func, ls) να επιστρέφει True εάν και μόνο εάν η κλήση func(x) έχει τιμή True <em>για</em> <em>όλα</em> τα στοιχεία x της λίστας ls. </p>
<p><em>Η υλοποίησή σας θα πρέπει να χρησιμοποιεί επεξεργασία ακολουθιών με <strong>list comprehensions</strong>, <span style="text-decoration:underline;">χωρίς αναδρομικό ή </span><span style="text-decoration:underline;">επαναληπτικό υπολογισμό, (δηλ., την εντολή while ή for) </span>. (Στις ασκήσεις 6 εως 9 θα υλοποιήσετε την ίδια συνάρτηση με τους άλλους τρόπους.)</em></p>
<pre>def all_lc(func, ls):<br />    """True mono ean i klisi func(x) epistrefei True <br />    gia ola ta stoixeia x tis ls.<br /><br />    func -- synartisi enos orismatos<br />    ls -- lista<br /><br />    Paradeigmata:<br />    &gt;&gt;&gt; all_lc(lambda x: x &gt;= 0, [1, 2, 3, 0, 4])<br />    True<br />    &gt;&gt;&gt; all_lc(lambda x: x &gt;= 0, [1, 2, -3, 0, 4])<br />    False<br />    &gt;&gt;&gt; all_lc(lambda x: x % 2 == 0, [100, 10, 2022, 12])<br />    True<br />    """<br />    """XRHSIMOPOIHSTE EPE3ERGASIA AKOLOU8IWN ME LIST COMPREHENSIONS.<br />    MHN XRHSIMOPOIHSETE ANADROMH 'h EPANALHPTIKO YPOLOGISMO <br />    (for 'h while)."""<br />    """GRAPSTE TON KWDIKA SAS APO KATW."""</pre>
<h3>Άσκηση 9</h3>
<p>Συμπληρώστε τον κώδικα στη συνάρτηση all_hof έτσι ώστε η κλήση all_hof(func, ls) να επιστρέφει True εάν και μόνο εάν η κλήση func(x) έχει τιμή True <em>για</em> <em>όλα</em> τα στοιχεία x της λίστας ls. </p>
<p><em>Η υλοποίησή σας θα πρέπει να χρησιμοποιεί επεξεργασία ακολουθιών <strong>με συναρτήσεις ανώτερου επιπέδου (map, filter, reduce)</strong>, <span style="text-decoration:underline;">χωρίς αναδρομικό ή </span><span style="text-decoration:underline;">επαναληπτικό υπολογισμό, (δηλ., την εντολή while ή for) ή comprehensions </span>. (Στις ασκήσεις 6 εως 8 θα υλοποιήσετε την ίδια συνάρτηση με τους άλλους τρόπους.)</em></p>
<pre>def all_hof(func, ls):<br />    """True mono ean i klisi func(x) epistrefei True <br />    gia ola ta stoixeia x tis ls.<br /><br />    func -- synartisi enos orismatos<br />    ls -- lista<br /><br />    Paradeigmata:<br />    &gt;&gt;&gt; all_hof(lambda x: x &gt;= 0, [1, 2, 3, 0, 4])<br />    True<br />    &gt;&gt;&gt; all_hof(lambda x: x &gt;= 0, [1, 2, -3, 0, 4])<br />    False<br />    &gt;&gt;&gt; all_hof(lambda x: x % 2 == 0, [100, 10, 2022, 12])<br />    True<br />    """<br />    """XRHSIMOPOIHSTE EPE3ERGASIA AKOLOU8IWN ME SYNARTHSEIS ANWTEROY EPIPEDOY<br />    (map, filter, reduce).<br />    MHN XRHSIMOPOIHSETE ANADROMH, EPANALHPTIKO YPOLOGISMO (for 'h while)<br />    'h LIST COMPREHENSIONS."""<br />    """GRAPSTE TON KWDIKA SAS APO KATW."""</pre>
<h3>Άσκηση 10</h3>
<p>Συμπληρώστε τον κώδικα στη συνάρτηση primes_up_to έτσι ώστε η κλήση primes_up_to(n) να επιστρέφει λίστα που περιέχει όλους τους πρώτους αριθμούς μικρότερους ή ίσους του n. <em>(Ένας αριθμός είναι πρώτος εάν είναι μεγαλύτερος ή ίσος του 2 και δεν έχει άλλους διαιρέτες εκτός φυσικά το 1 και τον ίδιο.)</em></p>
<p><em>Η υλοποίησή σας θα πρέπει να χρησιμοποιεί το "κόσκινο του Ερατοσθένη" με επαναληπτικό φιλτράρισμα ακολουθιών, όπως περιγράφεται στη <a href="/modules/document/file.php/INF259/%CE%94%CE%B9%CE%B1%CE%BB%CE%AD%CE%BE%CE%B5%CE%B9%CF%82/7_Sequences.pdf">διάλεξη 7</a>, <strong>με επεξεργασία ακολουθιών (list comprehensions ή συναρτήσεις ανώτερου επιπέδου)</strong>. Χρησιμοποιήστε εντολή επανάληψης για την επαναληπτική εφαρμογή του φιλτραρίσματος.</em></p>
<pre>def primes_up_to(n):<br />    """Prwtoi ari8moi ews to n.<br /><br />    n -- akeraios &gt;= 2<br /><br />    Epistrefei lista me olous tous prwtous ari8mous mikroterous 'h isous me n.<br /><br />    Paradeigmata:<br />    &gt;&gt;&gt; primes_up_to(10)<br />    [2, 3, 5, 7]<br />    &gt;&gt;&gt; primes_up_to(20)<br />    [2, 3, 5, 7, 11, 13, 17, 19]<br />    &gt;&gt;&gt; len(primes_up_to(10000))<br />    1229<br />    """<br />    """XRHSIMOPOIHSTE EPE3ERGASIA AKOLOU8IWN ME LIST COMPREHENSIONS 'h<br />    SYNARTHSEIS ANWTEROY EPIPEDOY (map, reduce, filter)."""<br />    """GRAPSTE TON KWDIKA SAS APO KATW."""</pre>
<p> </p>
</body>
</html>
